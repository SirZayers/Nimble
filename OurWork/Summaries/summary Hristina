#Nimble

Nimble is an available append only ledger service.Main goals: linearizability, trusted code is as small as possible and simple enough that it can be audited by customers. if an honest provider runs Nimble as specified, the service will be live. avoid reimplementing complex replication protocols
Reuses existing storage services for simplicity
Cloud service that helps applications in TEEs prevent rollback attacks
The TEEs cannot remember the current state, when code execution is interrupted. Nimble provides a machine that saves the most recent state
While other solutions donot support reconfigurations, where the set of TEEs changes over time, Nimble does.
Focus is put on providing safety, liveness is ensured by the cloud provider 
Given the signature in the block, the ledger service cannot append a block anywhere different than its expected index


Endorser: a small amount of code (trusted state machine) runs inside a TEE, it holds the tail of the ledger in its protected volatile memory. endorsers have no API to rollback their state. Liveness is ensured by instantiating multiple endorsers. Produces fresh key pair, so the TEE can show that the endorser is legitimate, endorser signs its response with the key. When Nimble boots up, it produces a unique and static identifier that is derived by hashing the public keys of the endorsers. We assume that this identifier is public knowledge. Response and receipt are expected from client. Endorsers are tied to a particular configuration, hold the kezs for previous, current and next configuration.


Rollback attacks : (1) stale responses, where a malicious storage service provider returns a prior version of data instead of the latest i.e., lack of freshness--- append-only ledger service that guarantees linearizability (2) synthesized requests, where a malicious provider synthesizes requests on its own (i.e., they were never issued by the application) and applies them to the storage (thereby affecting future reads) --- signing key in a signature scheme that is known only to the application (3) replay, where a malicious provider uses valid requests that were previously sent by the application and applies them to the storage again.--- the signature stored in an appended block covers not only the application’s state, but also the position of the block in the ledger
Storing state in an existing UNTRUSTED storage service (1) it persists its state in an existing storage service and then (2) stores a cryptographic digest of that state in the ledger. it checks that the digest of the state retrieved from the storage service equals the digest from the ledger service. The application may fail after it performs step (1) but before step (2), during updates. Therefore, the application uses S ′ , c + 1, and σ , stored in the application, from the storage service to complete its pending append to the ledger service.

Coordinator: Nimble employs a collection of worker processes, which we refer to as coordinators. They are stateless and untrusted, and their job is to process requests from clients. invokes the APIs provided by the endorser state machine and the untrusted state machine to provide the APIs. calls initialize(c) on the untrusted state machine and when that succeeds, it calls initialize(c) on the endorser state machine
For each ledger, Nimble maintains a hash chain (a linked list where each node contains data and a cryptographic hash of the previous node) in untrusted cloud storage service

Client: (1) public keys in the receipt are in Ccurr; (2) signatures are valid when verified with the known id and Ccurr (as well as other information specific to a request); (3) there is a quorum of valid signatures based on the number of public keys in Ccurr.
